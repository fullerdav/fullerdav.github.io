<!DOCTYPE html>
<html lang="en_US"> 
<head>
<title>Schaffer Library Find and Request</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="author: david fuller, title: purchase request">
<meta name="keywords" content="schaffer library purchase request form">
<link rel="icon" href="icons/request.png" type="image/png" sizes="84x84"> 
<style>
    .container {
      display: grid;
      grid-template-columns: 2fr 3fr;
      grid-template-rows: 0.5fr 2fr 1fr 0.5fr;
      grid-auto-flow: row;
      grid-template-areas: 
      "requestform  panel"
      "requestform  panel"
      "requestform  panel"
      "requestform  panel";
      width: 50%;
      height: 24em;
      /*min-height: 23em;*/
      border-radius: 8px;
      border: 1px inset #007dba;
      border-left-width: 3px; 
      border-top-width: 2px; 
      box-shadow: 0 0 2px 0px #007dba;
      font: 525 100%/1.2 Roboto,sans-serif;
      font-size: 15px;
      background: radial-gradient(ellipse farthest-corner at center center, #fcf6e8 95%, rgba(171,157,157,0.1) 50%);
      margin: 1em;
    }
    .requestform {
      grid-area: requestform;
      grid-template-rows: 1fr 5fr 1fr 1fr;
      grid-template-areas:
        "title"
        "inputels"
        "status"
        "buttons";
      padding: 0.5em;
    }    
    .title {
      grid-area: title;
      padding: 0.5em;
    } 
    ul.flexer {
      grid-area: inputels;
      padding: 0.5em;
    }  
    .status {
      grid-area: status;
      color: red;
      font-size: 0.9em;
      letter-spacing: .08em;
      height: 2em;
      padding: 0.5em;
    }
    .buttons {
       grid-area: buttons;
       padding: 0.5em;
    }

    .panel {
      display: grid;
      grid-area: panel;
      grid-template-rows: 1fr 7fr;
      grid-template-areas:
        "helpme"
        "thumbnails";
    } 
    .panel > img {
      margin: 4px 0;
      height: 25px;
    }
    .help {
      grid-area: helpme;
    }
    .thumbnails {
      grid-area: thumbnails;
      display: flex;
      flex-flow: column nowrap;
      justify-content: flex-start;
      align-content: flex-start;
      overflow-y: scroll;
    }
    .thumbnails > a {
      display: flex; 
      width: 100%;
      margin-top: 0.25em;
      text-decoration: none;
      font-family: Courier, sans-serif;
      font-size: 16px;
      background-color: whitesmoke;
      border: 0.25em outset #fcf6e833;
      padding: 0.25em;
      color: whitesmoke;
      transition: color 1.2s ease-in;
      transition-delay: 5s;
    }
    .thumbnails > a:hover {
      border-style: inset;
    }
    .cite {
      flex: 1 80%; 
    }
    .thumb {
      flex: 1 20%;
      margin: 0;
    }
    .thumb > img {
      height: 8em;
      padding: 0.25em;
    }
    button {  
      max-height: 2.5em;
      margin: 0.5em;
      padding: 0.1em 0.35em;
      color: white;
      background: #3daaff;
      border: 0.4em outset #2299ff;
      border-radius: 6px;
    } 
    input {
      padding: 0.25em;
      border: 2px inset #dedede;
      width: 18em;
      line-height:1.35em; 
      background-color: whitesmoke;
    }
    ul { 
      list-style-type: none; 
      margin: 0;
      padding: 0.5em;
    }  
    ul.flexer > li {
      display: flex;
      flex-wrap: nowrap;
      margin: 0.25em 0;
    }
    ul.flexer > li > label {
      padding: 0.25em;
      letter-spacing:.08em;
      width: 4.25em; 
    }    
    input[type="checkbox"] {
      width: 1em; 
      height: 1.5em;
    }  
    input[data-name="mms"], input[data-name="oclcid"] {
      line-height: 0.01;
    }
    
    .littlebox {
      opacity: 0;
      margin: 4px 0;
      font-size: 0.1em;
      position: absolute;  
      width: auto;
      transition: opacity 1.2s cubic-bezier(0.35, 0.25, 0.25, 0.34);
    }
    .expandbox {
      top: 3em;
      display: inline-block;
      font-size: 0.9em;
      opacity: 1;
      z-index: 10;    
      background-color: white;    
      border-radius: 1%;
      cursor: pointer;     
    } 

  </style>
</head>
 
<body>
    <div class="container"> 
      <div class="panel">
        <img src="icons/help.png" onclick="showHelp();">
          <span class="help littlebox">
          <ul>Requesting books and videos:   
            <li>Enter an ISBN&lt;TAB&gt; or other data</li> 
            <li>distinctive keywords usually suffice...</li> 
            <li>We'll check availability and populate a request</li>
            <li>remember: login to see all options</li>
            <li></li>
            <ul>Best practices for locating videos:
              <li><b>Author</b> varies, best to omit</li>
              <li><b>Pub.</b> refers to studio or distributor</li>     
              <li><b>Year</b> refers to release, not production</li> 
              <li>remember to check the "video" box!</li>
              <li></li>
              <ul><b>[title, pub, year]</b> examples:
                <li>The Way We Were, Columbia, 1999</li>
                <li>Dersu Uzala, kino, 2000</li>
                <li>dersu, Kino</li>
              </ul>
            </ul>
          </ul>
          </span>
        <div class="thumbnails"></div>
      </div>

      <div class="requestform">     
          <span class="title">Locate, then request</span>
          <ul class="flexer">
            <li>
              <input type="hidden" name="rft.oclcnum" data-name="oclcid" value=""> 
              <input type="hidden" name="rft.mms_id" data-name="mms" value="">
              <input type="hidden" name="rft.edition" data-name="edition" value="">
            </li><li>
              <label for="rft.isbn">ISBN</label>
              <input type="search" name="rft.isbn" data-name="isbn" data-gbname="industryIdentifiers" autocomplete="off"  placeholder="add then press <TAB>" value="" autofocus>
            </li><li>
              <label for="rft.btitle">Title</label>
              <input type="search" name="rft.btitle" data-name="btitle" data-gbname="title" value="">
            </li><li>
              <label for="rft.au">Author</label>
              <input type="search" name="rft.au" data-name="addau" data-gbname="authors" value="">
            </li><li>
              <label for="rft.publisher">Pub.</label>
              <input type="search" name="rft.publisher" data-name="pub" data-gbname="publisher" value="">
            </li><li>  
              <label for="rft.pubdate">Year</label>
              <input type="search" name="rft.pubdate" data-name="creationdate" data-gbname="publishedDate" pattern="\d{4}" value="" minlength="4" maxlength="4">
            </li><li>
              <label for="video">Video?</label> 
              <input type="checkbox" name="videos">
            </li> 
          </ul>

          <div class="status"></div>
          <div class="buttons">
            <button name="reset" onclick="startOver();">&circlearrowleft;</button> 
            <button name="sub" onclick="searchController();">Locate data</button> 
          </div>          
      </div>
  </div> 
</body>

<script>
//// variables
  "use strict";
  let ISBN, ISBN_SEARCH, TITL_SEARCH, FOUND = false, CURSOR = 0, RISTYPE = "BOOK", searchkeys = {};
  let recordset = {"primapi":{"records":[],"mapper":mapAPI}, "gobooks":{"records":[],"mapper":mapGoogle },"oclcapi":{"records":[],"mapper":mapAPI}};
  const status = document.querySelector(".status");
  const thumbs = document.querySelector(".thumbnails");
  const datanames = document.querySelectorAll('[data-name]');
  const {log} = console;

//// set targets
  function setURI(targ, keys) {  
      let terms = []; 
      for (let key of Object.keys(searchkeys)) {
        if (keys[key] && searchkeys[key]) {
          terms.push(keys[key] + searchkeys[key]);
        }
      }   
      let uri = (targ === "gobooks") ?  uri = terms.join(" ") : terms.join(",AND;");
      return uri;
  };

  function setURL(target) {
    let url = new URL(urls[target]);
    if (target === "gobooks") {
       url.searchParams.set("q", "isbn:" + ISBN);
    } else {
       url.searchParams.set("q", setURI(target, urikeys[target]));
       if (RISTYPE === "VIDEO") { 
        url.searchParams.set("qInclude", "facet_rtype,exact,videos");
       } else {
        url.searchParams.set("multiFacets", "facet_rtype,include,books|,|facet_rtype,include,videos");
       }
    }
    return url;
  }   
 
//// Normalize results
  function mapAPI(records) {
    records.forEach(record => {
      let item = {};
      let newitem = thumbFactory();
      let [anchor, div, img] = newitem.querySelectorAll("a, div, img");

      ['isbn', 'btitle', 'au', 'addau', 'pub', 'ristype', 'creationdate', 'edition', 'oclcid', 'mms', 'date'].forEach(el => {
           item[el] = ((record[el] !== undefined) && Array.isArray(record[el])) ? record[el][0] : record[el];
      });
      item["creationdate"] = (item["creationdate"] !== undefined) ?  item["creationdate"].match(/^\d{4}/)[0] : item["date"].match(/^\d{4}/)[0];
      item["author"] = (item["addau"] !== undefined) ? item["addau"] : (item["au"] !== undefined) ? item["au"] : "";
      let rtype = (item["ristype"] !== undefined) ? item["ristype"] : (record["type"] !== undefined) ? record["type"] : "";
      
      div.innerHTML = formatCitation(rtype, item);
      fetchThumbnail(item['isbn']).then(thumburl => {
          img.src = thumburl ? thumburl : `icons/icon_${rtype.toLowerCase()}.png`;
      });  
      
      let location = searchTarget(item);
      anchor.href = `javascript:(window.open('${location}', '_blank'))`;
      thumbs.appendChild(newitem);
    });  
  }

  function mapGoogle(records) {
    records.forEach(record => {
      let item = {}; 
      let newitem = thumbFactory();
      let [anchor, div, img] = newitem.querySelectorAll("a, div, img");
      
      item['isbn'] = (record.industryIdentifiers[1]) ? record.industryIdentifiers[1].identifier : record.industryIdentifiers[0].identifier;
      item['btitle'] = (record["title"] && Array.isArray(record['title'])) ? record["title"][0] : record["title"];
      item['addau'] = (record["authors"] && Array.isArray(record['authors'])) ? record["authors"][0] : record["authors"];
      item['creationdate'] = (record["publishedDate"]) ? record["publishedDate"].match(/^\d{4}/)[0] : "";
      item['pub'] = (record["publisher"] && Array.isArray(record['publisher'])) ? record["publisher"][0] : record["publisher"];
      
      img.src = (record.imageLinks && record.imageLinks.smallThumbnail) ? record.imageLinks.smallThumbnail : "icons/icon_book.png";
      div.innerHTML = formatCitation("BOOK", item);

      let location = searchTarget(item);
      anchor.href = `javascript:(window.open('${location}', '_blank'))`;
      thumbs.appendChild(newitem);
    });
  }

  function filterAPI(recordset) {
    let records = recordset.filter(record => {
      let FILTER = true;     
   
      if (searchkeys.hasOwnProperty('rft.btitle')) {  
        let recordtitle = (record.btitle && Array.isArray(record.btitle)) ? record.btitle[0] : record.btitle;
        recordtitle = recordtitle ? recordtitle.toLowerCase() : (record.title && Array.isArray(record.title)) ? record["title"][0].toLowerCase() : record["title"].toLowerCase();
        if (recordtitle) {
          let searchtitle = searchkeys['rft.btitle'].toLowerCase();
          FILTER = FILTER && recordtitle.includes(searchtitle);
        }
      }      
      if (searchkeys.hasOwnProperty('rft.pubdate') && FILTER) {
        let recordate = (record.creationdate && Array.isArray(record.creationdate)) ? record.creationdate[0] : record.creationdate;
        if (recordate) {
          FILTER = FILTER && recordate.includes(searchkeys['rft.pubdate']);
        }
      }
      if (searchkeys.hasOwnProperty('rft.publisher') && FILTER) {   
        let recordpub = (record.pub && Array.isArray(record.pub)) ? record.pub[0].toLowerCase() : record.pub.toLowerCase(); 
        if (recordpub) {
          let searchpub = searchkeys['rft.publisher'].toLowerCase();
          FILTER = FILTER && recordpub.includes(searchpub);
        }
      }
      if (searchkeys.hasOwnProperty('rft.au') && FILTER) {
        let recordau = (record.authors && Array.isArray(record.authors)) ? record.authors[0] : record.authors;
        if (recordau) {
          let searchau = searchkeys['rft.au'].toLowerCase();
          FILTER = FILTER && recordau.includes(searchau);
        }
      }
      return FILTER;      
    });
    return records;
  }
 
//// fetch data
  async function fetchThumbnail(isbn) {
      if (!isbn) { return false; }
      let bibkey = "isbn:" + isbn, data, response;
      let url = new URL(urls.gobooks);
      url.searchParams.set("q", bibkey);

      try {
        response = await fetch(url.href);
        data = await response.json();
      } catch(e) { 
        status.innerHTML = e; 
      }
      
      if (!response.ok) {
        response = null, data = null;
        try {
          response = await fetch(`https://covers.openlibrary.org/a/isbn/${isbn}-S.jpg`);
          let oldata = await response.blob();
          log(oldata);
        } catch(e) { 
          status.innerHTML = e; 
        }
      }
      
      if (data && data.totalItems === 1) {
        if (data.items[0].volumeInfo.imageLinks.smallThumbnail !== undefined) {
          return data.items[0].volumeInfo.imageLinks.smallThumbnail;
        } 
      } else if (olresponse.ok) {
         return olresponse.url;
      } else {
         return false;
      }
  }

  async function fetchJSON(target) {
      let data; 
      try {   
        let url = setURL(target);
        let response = await fetch(url.href);
        data = await response.json();    
      } catch(e) { 
        status.innerHTML = e; 
      } 
      return data;
  }
    
//// controller
  async function searchController() {
      while (thumbs.firstChild) {
        thumbs.removeChild(thumbs.firstChild);
      } 
 
      ["primapi","gobooks","oclcapi"].forEach(source => {
        recordset[source].records = [];
        recordset[source].found = () => recordset[source].records.length > 0;
        recordset[source].totrecs = () => recordset[source].records.length;
      });  
      
      document.querySelectorAll('[name^=rft]').forEach(el => {
        if (el.value) { searchkeys[el.name] = el.value; }
      });

      ISBN_SEARCH = searchkeys["rft.isbn"] ? true : false ;    
      TITL_SEARCH = (searchkeys["rft.btitle"] && !ISBN_SEARCH) ? true : false ;
     
      status.innerHTML = "Searching...";
      let time0 = performance.now(); 

      await fetchJSON("primapi").then(records => {
          if (records && records.docs) {
            const results = records.docs.map(item => {
              return { ...item.pnx.addata, ...item.pnx.display };
            });
            recordset["primapi"].records = filterAPI(results);
          }
      });  
          
      if (ISBN_SEARCH && !recordset["primapi"].found()) {
        await fetchJSON("gobooks").then(gb_records => {
          if (gb_records && gb_records.items) {
            recordset["gobooks"].records = gb_records.items.map(item => {
              return { ...item.volumeInfo, ...item.saleInfo };
            });
          }
        });         
      }
          
      if (!recordset["gobooks"].found() && !recordset["primapi"].found()) {
        await fetchJSON("oclcapi").then(oclc_records => {
          if (oclc_records && oclc_records.docs) {
            const results = oclc_records.docs.map(item => {
              return { ...item.pnx.addata, ...item.pnx.display };
            });
            recordset["oclcapi"].records = filterAPI(results);
          }
        });
      } 

      let time1 = performance.now();
      status.innerHTML = `Search completed: ${((time1 - time0)/1000).toFixed(2)}s<br>`;
      
      for (let key of Object.keys(recordset)) { 
        if (recordset[key].found()) { 
          FOUND = true;
          showRecords(key);
        }
      } 
      if (!ISBN_SEARCH && !TITL_SEARCH) { status.innerHTML = "Either ISBN or TITLE is required"; }
      if (!FOUND) { status.innerHTML += "No records found"; } 
  } 

  function showRecords(source) {
      const sources = {"primapi":"Primo", "oclcapi":"Worldcat", "gobooks":"Google"};
      status.innerHTML += `${recordset[source].totrecs()} record(s) found in ${sources[source]}`;
      recordset[source].mapper(recordset[source].records);
  }

//// event listeners
  document.querySelector('.littlebox').addEventListener("click", function(evt){    
    this.classList.toggle("expandbox");
  }, false); 

  document.querySelector('input[name="rft.isbn"]').addEventListener("blur", function(evt){  
    if (evt.target.value) {
      ISBN = evt.target.value.replace(/[^\dxX]/g,"");
      if (ISBN.length===10 || ISBN.length===13) {
        searchController();
      }
    }
  }, false); 

  document.querySelector('input[name="videos"]').addEventListener("change", function(evt){  
     RISTYPE = (evt.target.checked) ? "VIDEO" : "BOOK";
  }, false); 

//// data helpers
  const urls = {
    primreq: "https://union-psb.primo.exlibrisgroup.com/openurl/01UCNY_INST/01UCNY_INST:01UCNY_INST?url_ver=Z39.88-2004&ctx_ver=Z39.88-2004&ctx_enc=info:ofi/enc:UTF-8&rft_val_fmt=info:ofi/fmt:kev:mtx:book",
    primapi: "https://api-na.hosted.exlibrisgroup.com/primo/v1/search?vid=01UCNY_INST:Services&tab=Everything&scope=MyInst_and_CI&limit=8&conVoc=false&apikey=l7xxaa726f9cf9f74f048296f374d9ec74f5",
    oclcapi: "https://api-na.hosted.exlibrisgroup.com/primo/v1/search?vid=01UCNY_INST:Services&tab=oclc&scope=oclc&limit=8&conVoc=false&apikey=l7xxaa726f9cf9f74f048296f374d9ec74f5",
    gobooks: "https://www.googleapis.com/books/v1/volumes?",
  };

  const urikeys = { 
    "gobooks":{"rft.btitle":"intitle:", "rft.au":"inauthor:", "rft.publisher":"inpublisher:"},
    "oclcapi":{"rft.btitle":"title,exact,", "rft.au":"creator,contains,", "rft.pubdate":"creationdate,contains,", "rft.isbn":"isbn,contains,"},
    "primapi":{"rft.btitle":"title,exact,", "rft.au":"creator,contains,", "rft.pubdate":"cdate,contains,", "rft.isbn":"isbn,contains,"},
    "almasru":{"rft.btitle":"alma.title==", "rft.au":"alma.creator=", "rft.pub":"alma.publisher=", "rft.year":"alma.main_pub_date=="}
  };

  const searchParams = ['isbn:rft.isbn', 'btitle:rft.btitle', 'addau:rft.au', 'edition:rft.edition', 'pub:rft.publisher', 'creationdate:rft.pubdate', 'oclcid:rft.oclcnum', 'mms:rft.mms_id']
  
  function searchTarget(record){
    let url = new URL(urls.primreq); 
    searchParams.forEach(params => {
      let [rparam, sparam] = params.split(":");
      if (record[rparam] !== undefined) {
        url.searchParams.set(sparam, record[rparam]);
      }
    });
    return url;
  }

  function startOver() {
    datanames.forEach(el => { 
        el.value = ""; 
    });
    document.querySelector('input[name="videos"]').checked = false; 
    ["primapi","gobooks","oclcapi"].forEach(source => { recordset[source].records = []; });   
    [searchkeys, ISBN_SEARCH, TITL_SEARCH, ISBN, RISTYPE, CURSOR, FOUND] = [{}, undefined, undefined, undefined, "BOOK", 0, false]; 
    status.innerHTML = "";
  
    while (thumbs.firstChild) {
      thumbs.removeChild(thumbs.firstChild);
    } 
    document.querySelector('input[name="rft.isbn"]').focus(); 
  }

  function showHelp() {
    let box = document.querySelector(".littlebox");
    box.classList.toggle("expandbox");
  }

  function thumbFactory(caption) {
    let anchor = document.createElement('a');
    let div = document.createElement('div');
    let figure = document.createElement('figure'); 
    let img = document.createElement('img');
    div.classList.add("cite");
    figure.classList.add("thumb");
    figure.appendChild(img);
    anchor.appendChild(div);
    anchor.appendChild(figure);
 
    let fragment = new DocumentFragment();
    fragment.appendChild(anchor);
    return fragment;
  }

  function formatCitation(type, metadata) {
      let citation = `<b>${type}</b><br>`;
      ["addau", "btitle", "pub"].forEach(el => {
        if (metadata[el] !== undefined) {
          citation += metadata[el] + ", ";
        }
      });
      citation += (metadata["creationdate"] !== undefined) ? `${metadata["creationdate"]}.` : `.`; 
      return citation;
  }

  function watchThumbs() {
    const observedNode = document.querySelector('.thumbnails');
    const config = { attributes:true, childList:true, subtree:true };

    const callback = function(mutationsList, observer) {
      for (const mutation of mutationsList) {
        if (mutation.type === 'childList') {
          let anchor = mutation.addedNodes[0];
          anchor.style.color = 'black';
        }
      }  
    }
    const observer = new MutationObserver(callback);
    observer.observe(observedNode, config);
  }
  watchThumbs();

</script>
</html>

