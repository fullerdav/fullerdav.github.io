<!DOCTYPE html>
<html lang="en_US"> 
<head>
<title>Schaffer Library Find and Request</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="author: david fuller, title: purchase request">
<meta name="keywords" content="schaffer library purchase request form">
<link rel="icon" href="icons/request.png" type="image/png" sizes="84x84"> 
<style>
    .container {
      display: grid;
      grid-template-columns: 1fr 2fr;
      grid-template-rows: 0.5fr 2fr 1fr 0.5fr;
      grid-auto-flow: row;
      grid-template-areas: 
      "requestform  panel"
      "requestform  panel"
      "requestform  panel"
      "requestform  panel";
      width: 50%;
      height: 24em;
      border-radius: 8px;
      box-shadow: 1px 0 1px 1px #822433cc inset;
      border: 1px ridge #822433cc;
      font-family: Source Sans Pro, Helvetica Neue, sans-serif;
      font-size: 15px;
      color: #000000cc;
      background: #ededed;
      margin: 1em;
      transition:  all .4s cubic-bezier(.25,.8,.25,1);
      transform:  translateZ(0);
    }
    .requestform {
      grid-area: requestform;
      grid-template-rows: 1fr 5fr 1fr 1fr;
      grid-template-areas:
        "header"
        "inputels"
        "status"
        "buttons";
      padding: 0.5em;
    }    
    .header {
      grid-area: header;
      padding: 0.5em;
    } 
    ul.flexer {
      grid-area: inputels;
      padding: 0.5em;
    }  
    .status {
      grid-area: status;
      color: red;
      font-size: 0.9em;
      letter-spacing: .08em;
      height: 2em;
      padding: 0.5em;
    }
    .buttons {
       grid-area: buttons;
       padding: 0.5em;
    }

    .panel {
      display: grid;
      grid-area: panel;
      grid-template-rows: 1fr 7fr;
      grid-template-areas:
        "helpme"
        "thumbnails";
    } 
    .panel > img {
      margin: 4px 0;
      height: 2.5em;
      z-index: 10;
    }
    .help {
      grid-area: helpme;
    }
    .thumbnails {
      grid-area: thumbnails;
      display: flex;
      flex-flow: column nowrap;
      justify-content: flex-start;
      align-content: flex-start;
      overflow-y: scroll;    
    }
    .thumbnails > a {
      display: flex; 
      margin: 0.1em 0;
      text-decoration: none;
      line-height:  1.25;
      font-weight: 480;
      font-size: 0.9em;
      box-shadow: inset 0 0 0.15em 0.04em #822433cc;
      border: 1px outset #822433cc;
      background: #F6F6F6;
      padding: 0.5em 0.75em; 
      width: 95%;
      color: #000000cc;
      opacity: 0.8;
    }
    .thumbnails > a:hover {
      border-style: inset;
      background: white;
      opacity: 1;
    }
    .cite {
      flex: 1 1 auto;
      width: 90%; 
    }
    .promptxt {
      box-shadow: inset 2px 1px 2px 0 #822433cc;
      padding: 0.5em;
      margin:  0.25em 0;
    }
    .thumb {
      flex: 1 1 auto;
      margin: 0;
    }
    .thumb > img {
      height: 6em;
      padding: 0.25em;
    }
    .rtype {
      font-size: 0.75em;
      font-weight: 600;
      letter-spacing: .07em;
      text-transform: uppercase;
    }
    .rtype-video {
      color: #822433;
    }
    .rtype-book {
      color: #28F;
    }
    .btitle {
      font-weight: 600;
      font-size: 1.1em;
      margin: 0.35em 0;
      align-self: flex-start;
      color: #000000cc;
    }
    button {  
      max-height: 2.5em;
      margin: 0.5em;
      padding: 0.1em 0.35em;
      color: white;
      background: #822433;
      border: 0.5em outset #82243399;
     /* background: #3daaff;
      border: 0.4em outset #2299ff;*/
      border-radius: 6px;
    } 
    input {
      padding: 0.25em;
      border: 2px inset #dedede;
      width: 18em;
      line-height:1.35em; 
      background-color: whitesmoke;
    }
    ul { 
      list-style-type: none; 
      margin: 0;
      padding: 0.5em;
    }  
    ul.flexer > li {
      display: flex;
      flex-wrap: nowrap;
      margin: 0.25em 0;
    }
    ul.flexer > li > label {
      padding: 0.25em;
      letter-spacing:.08em;
      width: 4.25em; 
    }    
    input[type="checkbox"] {
      width: 1em; 
      height: 1.5em;
    }  
    input[data-name="mms"], input[data-name="oclcid"] {
      line-height: 0.01;
    }
    
    .littlebox {
      opacity: 0;
      margin: 4px 0;
      font-size: 0.1em;
      position: absolute;
      top: 3em;
      width: auto;
      z-index: 10;   
      transition: opacity 1.4s ease-out;
    }
    .expandbox {
      display: inline-block;
      font-size: 0.9em;
      opacity: 1;
      background-color: white;    
      border-radius: 2%;
    } 
    .primolink {
     
      padding: 0;
      margin: 0.25em 0;
      line-height: inherit;
      white-space: normal;
      text-align: inherit;
      overflow: visible;
      font-size: 0.9em;
      border-radius: 0;
      padding-bottom: 0.1em;
      text-decoration: none; 
      text-transform: none;
      box-shadow: inset 0 -1px 0 0 rgb(61 110 148 / 0%);
      display: inline;
      cursor: pointer;
    }
  </style>
</head>
 
<body>
    <div class="container"> 
      <div class="panel">
        <img src="icons/help.png" onclick="showHelp();">
          <span class="help littlebox">
          <ul>Requesting books and videos:   
            <li>Enter an ISBN&lt;TAB&gt; or other data</li> 
            <li>distinctive keywords usually suffice...</li> 
            <li>We'll check availability and populate a request</li>
            <li>remember: login to see all options</li>
            <li></li>
            <ul>Best practices for locating videos:
              <li><b>Author</b> varies, best to omit</li>
              <li><b>Pub.</b> refers to studio or distributor</li>     
              <li><b>Year</b> refers to release, not production</li> 
              <li>remember to check the "video" box!</li>
              <li></li>
              <ul><b>[title, pub, year]</b> examples:
                <li>The Way We Were, Columbia, 1999</li>
                <li>Dersu Uzala, kino, 2000</li>
                <li>dersu, Kino</li>
              </ul>
            </ul>
          </ul>
          </span>
        <div class="thumbnails"></div>
      </div>

      <div class="requestform">     
          <span class="header">Locate, then request</span>
          <ul class="flexer">
            <li>
              <input type="hidden" name="rft.oclcnum" data-name="oclcid" value=""> 
              <input type="hidden" name="rft.mms_id" data-name="mms" value="">
              <input type="hidden" name="rft.edition" data-name="edition" value="">
            </li><li>
              <label for="rft.isbn">ISBN</label>
              <input type="search" name="rft.isbn" data-name="isbn" data-gbname="industryIdentifiers" autocomplete="off"  placeholder="add then press <TAB>" value="" autofocus>
            </li><li>
              <label for="rft.btitle">Title</label>
              <input type="search" name="rft.btitle" data-name="btitle" data-gbname="title" value="">
            </li><li>
              <label for="rft.au">Author</label>
              <input type="search" name="rft.au" data-name="addau" data-gbname="authors" value="">
            </li><li>
              <label for="rft.publisher">Pub.</label>
              <input type="search" name="rft.publisher" data-name="pub" data-gbname="publisher" value="">
            </li><li>  
              <label for="rft.pubdate">Year</label>
              <input type="search" name="rft.pubdate" data-name="creationdate" data-gbname="publishedDate" pattern="\d{4}" value="" minlength="4" maxlength="4">
            </li><li>
              <label for="video">Video?</label> 
              <input id="ristype" type="checkbox" value="VIDEO" name="videos">
            </li> 
          </ul>

          <div class="status"></div>
          <div class="buttons">
            <button name="reset" onclick="startOver();">&circlearrowleft;</button> 
            <button name="sub" onclick="searchController();">Locate data</button> 
          </div>          
      </div>
  </div> 
</body>

<script>
//// variables
  "use strict";
 'use strict';
 let searchkeys = {};
 const status = document.querySelector(".status");
 const thumbs = document.querySelector(".thumbnails");
 const RISTYPE = document.querySelector("#ristype");
 const newThumb = genThumb();
 const { log } = console;

 let recordset = {"primapi":{"records":[],"mapper":makeAPI}, "gobooks":{"records":[],"mapper":makeGoogle },"oclcapi":{"records":[],"mapper":makeAPI}};
  for (let key of Object.keys(recordset)) { 
   recordset[key].totrecs = () => { return recordset[key].records.length; }
   recordset[key].found = () => { return recordset[key].records.length > 0; }
  }

 //// Normalize results
 async function makeAPI(records) {
   let API = recordset["primapi"].found() ? "Primo" : "Worldcat";
   genHeader(API);
   records.forEach(record => {
     let item = {};
     let newitem = newThumb.cloneNode(true);
     let [anchor, div, img] = newitem.querySelectorAll("a, div, img");

     ['isbn', 'btitle', 'pub', 'edition', 'oclcid', 'mms', 'creationdate', 'date', 'au', 'addau', 'description', 'ristype', 'type', 'format'].forEach(el => {
       if (record.hasOwnProperty(el)) {
         item[el] = record[el].toString().trim();
       }
     });

     item["creationdate"] = item.hasOwnProperty("creationdate") ? item["creationdate"] : item.hasOwnProperty("date") ? item["date"] : undefined;
     item["ristype"] = item.hasOwnProperty("ristype") ? item["ristype"].toLowerCase() : item.hasOwnProperty("type") ? item["type"].toLowerCase() : undefined;
     item["au"] = item.hasOwnProperty("au") ? item["au"] : record.hasOwnProperty("addau") ? record["addau"] : undefined;

     for (let key of Object.keys(item)) { if (item[key] === undefined) { delete item[key]; } }

     div.innerHTML = genCitation(item);
     fetchThumbnail(item['isbn']).then(thumburl => {
       img.src = thumburl ? thumburl : `icons/icon_${item["ristype"]}.png`;
     });
     thumbs.appendChild(newitem);
   });
 }

 async function makeGoogle(records) {
   genHeader("GOOGLE");
   records.forEach(record => {
     let item = {};
     let newitem = newThumb.cloneNode(true);
     let [anchor, div, img] = newitem.querySelectorAll("a, div, img");

     item['isbn'] = (record.industryIdentifiers[1]) ? record.industryIdentifiers[1].identifier : record.industryIdentifiers[0].identifier;
     item['btitle'] = (record["title"] && Array.isArray(record['title'])) ? record["title"][0] : record["title"];
     item['au'] = (record["authors"] && Array.isArray(record['authors'])) ? record["authors"][0] : record["authors"];
     item['creationdate'] = record["publishedDate"] ? record["publishedDate"].match(/^\d{4}/)[0] : "";
     item['pub'] = (record["publisher"] && Array.isArray(record['publisher'])) ? record["publisher"][0] : record["publisher"];
     item["ristype"] = "book";
     img.src = (record.imageLinks && record.imageLinks.smallThumbnail) ? record.imageLinks.smallThumbnail : "icons/icon_book.png";
     div.innerHTML = genCitation(item);
     thumbs.appendChild(newitem);
   });
 }

 function filterAPI(recordset) {
   let records = recordset.filter(record => {
     let FILTER = true;

     if (searchkeys.hasOwnProperty('rft.btitle')) {
       let recordtitle = record.btitle ? record.btitle : record.title;
       if (recordtitle) {
         recordtitle = recordtitle.toString().toLowerCase();
         let searchtitle = searchkeys['rft.btitle'];
         FILTER = FILTER && recordtitle.includes(searchtitle);
       }
     }
     if (searchkeys.hasOwnProperty('rft.pubdate') && FILTER) {
       let recordate = record.creationdate ? record.creationdate : record.date;
       if (recordate) {
         recordate = recordate.toString().toLowerCase();
         let searchdate = searchkeys['rft.pubdate'];
         FILTER = FILTER && recordate.includes(searchdate);
       }
     }
     if (searchkeys.hasOwnProperty('rft.publisher') && FILTER) {
       let recordpub = record.pub ? record.pub : record.publisher;
       if (recordpub) {
         recordpub = recordpub.toString().toLowerCase();
         let searchpub = searchkeys['rft.publisher'];
         FILTER = FILTER && recordpub.includes(searchpub);
       }
     }
     if (searchkeys.hasOwnProperty('rft.au') && FILTER) {
       let recordau = record.au ? record.au : record.addau;
       if (recordau) {
         recordau = recordau.toString().toLowerCase();
         let searchau = searchkeys['rft.au'];
         FILTER = FILTER && recordau.includes(searchau);
       }
     }
     if (record.hasOwnProperty("ristype") && FILTER) {
       let ristype = record.ristype ? record.ristype : record.type;
       if (ristype) {
         ristype = ristype.toString().trim().toLowerCase();
         FILTER = FILTER && (ristype === "video" || ristype === "book");
       }
     }

     return FILTER;
   });
   return records;
 }

 //// fetch data
 async function fetchThumbnail(isbn) {
   if (!isbn) { return false; }

   let bibkey = "isbn:" + isbn,
     data, response, oldata, olresponse, imgurl;
   let url = new URL(urls.gobooks);
   url.searchParams.set("q", bibkey);

   try {
     response = await fetch(url.href);
     data = await response.json();
   } catch (e) {
     status.innerHTML = e;
   }

   if (!response.ok) {
     try {
       olresponse = await fetch(`https://covers.openlibrary.org/a/isbn/${isbn}-S.jpg`);
       let oldata = await olresponse.blob();
     } catch (e) {
       status.innerHTML = e;
     }
   }

   if (response && response.ok) {
     if (data && data.totalItems === 1) {
       let thumbnail = data.items[0].volumeInfo.imageLinks;
       if (thumbnail && thumbnail.smallThumbnail) {
         imgurl = thumbnail.smallThumbnail;
       }
     }
   } else if (olresponse && olresponse.ok) {
     if (oldata && oldata.url) {
       log("OL thumbnail needed", isbn)
       imgurl = data.url;
     }
   } else {
     imgurl = false;
   }
   return imgurl;
 }

 async function fetchJSON(target) {
   let data;
   try {
     let url = genURL(target);
     let response = await fetch(url.href);
     data = await response.json();
   } catch (e) {
     status.innerHTML = e;
   }
   return data;
 }

 //// controller
 async function searchController() {
   clearAnchors();
   searchkeys = {};
   document.querySelectorAll('[name^=rft]').forEach(el => {
     if (el.value) {
       searchkeys[el.name] = el.value.trim().toLowerCase();
     }
   });

   let ISBN_SEARCH = searchkeys["rft.isbn"] ? true : false;
   let TITL_SEARCH = (searchkeys["rft.btitle"] && !ISBN_SEARCH) ? true : false;
   status.innerHTML = "Searching...";
   let time0 = performance.now();

   await fetchJSON("primapi").then(records => {
     if (records && records.docs) {
       const results = records.docs.map(item => {
         return { ...item.pnx.addata, ...item.pnx.display, ...item.pnx.control };
       });
       recordset["primapi"].records = filterAPI(results);
     }
   });

   if (ISBN_SEARCH && !recordset["primapi"].found()) {
     await fetchJSON("gobooks").then(gb_records => {
       if (gb_records && gb_records.items) {
         recordset["gobooks"].records = gb_records.items.map(item => {
           return { ...item.volumeInfo, ...item.saleInfo };
         });
       }
     });
   }

   if (!recordset["gobooks"].found() && !recordset["primapi"].found()) {
     await fetchJSON("oclcapi").then(oclc_records => {
       if (oclc_records && oclc_records.docs) {
         const results = oclc_records.docs.map(item => {
           return { ...item.pnx.addata, ...item.pnx.display, ...item.pnx.control };
         });
         recordset["oclcapi"].records = filterAPI(results);
       }
     });
   }

   let time1 = performance.now();
   status.innerHTML = `Search completed: ${((time1 - time0)/1000).toFixed(2)}s<br>`;
   showRecords();
 }

 function showRecords() {
   const sources = {"primapi":"Primo", "oclcapi":"Worldcat", "gobooks":"Google" };
   for (let key of Object.keys(recordset)) {
     if (recordset[key].found()) {
       status.innerHTML += `${recordset[key].totrecs()} record(s) found in ${sources[key]}`;
       recordset[key].mapper(recordset[key].records);
     }
   }
 }

 function startOver() {
   document.querySelectorAll('[data-name]').forEach(el => { el.value = ""; });
   RISTYPE.checked = false;
   status.innerHTML = "";
   document.querySelector('input[name="rft.isbn"]').focus();
   clearAnchors();
 }

 function clearAnchors() {
   if (thumbs && thumbs.firstChild) {
     while (thumbs.firstChild) {
       thumbs.removeChild(thumbs.firstChild);
     }
   }
 }

 ///constructors
 function genThumb() {
   let anchor = document.createElement('a');
   let div = document.createElement('div');
   let figure = document.createElement('figure');
   let img = document.createElement('img');
   div.classList.add("cite");
   figure.classList.add("thumb");

   figure.appendChild(img);
   anchor.appendChild(div);
   anchor.appendChild(figure);
   let fragment = new DocumentFragment();
   fragment.appendChild(anchor);
   return fragment;
 }

 function genCitation(record) {
   let location = genTargetURL(record);
   let citation = (record.hasOwnProperty("ristype")) ? `<span class="rtype ${record["ristype"] === "video" ? 'rtype-video' : 'rtype-book'}">${record["ristype"]}</span><br>` : `<span class="rtype">unknown</span><br>`;
   citation += (record.hasOwnProperty("btitle")) ? `<span class="btitle">${record["btitle"]}</span><br>` : "";
   citation += (typeof(record["au"]) === 'string') ? `<span>${record["au"]}</span><br>` : "";

   citation += (record.hasOwnProperty("pub")) ? `<span>${record["pub"]}</span>` : "";
   citation += (record.hasOwnProperty("pub") && record.hasOwnProperty("creationdate")) ? ` : ` : "";
   citation += (record.hasOwnProperty("edition")) ? `<br><span>${record["edition"]}</span>` : "";
   citation += (record.hasOwnProperty("creationdate")) ? `<span>${record["creationdate"]}</span>` : "";
   citation += (record.hasOwnProperty("format")) ? `<br><span>${record["format"]}</span>` : "";
   citation += (record.hasOwnProperty("format")) ? `<br><a href='javascript:window.open("${location}", "_blank");' class="primolink">View or request in Primo</a>` : "";
   return citation;
 }

 function genHeader(FOUND) {
   let headertxt;
   if (FOUND === "Primo") {
     headertxt = `<b>Owned!...maybe...check availability or place a request.</b><br>note: <i>login to Primo</i> to see request options or status of existing requests.`;
   } else {
     headertxt = `<b>Not owned</b>...select record to use data in requesting [ill, purchase].`;
   }
   let blq = document.createElement("blockquote");
   blq.classList.add("promptxt");
   blq.innerHTML = headertxt;
   document.querySelector(".thumbnails").appendChild(blq);
 }

 function genTargetURL(record) {
   const searchParams = ['isbn:rft.isbn', 'btitle:rft.btitle', 'addau:rft.au', 'edition:rft.edition', 'pub:rft.publisher', 'creationdate:rft.pubdate', 'oclcid:rft.oclcnum', 'mms:rft.mms_id'];
   let url = new URL(urls.primreq);
   searchParams.forEach(params => {
     let [rparam, sparam] = params.split(":");
     if (record[rparam] !== undefined) {
       url.searchParams.set(sparam, record[rparam]);
     }
   });
   return url;
 }

 function genURI(targ, keys) {
   let terms = [];
   for (let key of Object.keys(searchkeys)) {
     if (keys[key] && searchkeys[key]) {
       terms.push(keys[key] + searchkeys[key]);
     }
   }
   let uri = (targ === "gobooks") ? uri = terms.join(" ") : terms.join(",AND;");
   return uri;
 };

 function genURL(target) {
   let url = new URL(urls[target]);
   if (target === "gobooks") {
     url.searchParams.set("q", "isbn:" + ISBN);
   } else {
     url.searchParams.set("q", genURI(target, urikeys[target]));
     if (RISTYPE.checked) {
       url.searchParams.set("qInclude", "facet_rtype,include,videos");
     } else {
       url.searchParams.set("multiFacets", "facet_rtype,exact,books|,|facet_rtype,exact,videos");
     }
   }
   return url;
 }

 //// event listeners 
 document.querySelector('input[name="rft.isbn"]').addEventListener("blur", function(evt) {
   if (evt.target.value) {
     let ISBN = evt.target.value.replace(/[^\dxX]/g, "");
     if (ISBN.length === 10 || ISBN.length === 13) {
       searchController();
     }
   }
 }, false);

 function showHelp() {
   let box = document.querySelector(".littlebox");
   box.classList.toggle("expandbox");
 }

 //// data helpers
 const urls = {
   primreq: "https://union-psb.primo.exlibrisgroup.com/openurl/01UCNY_INST/01UCNY_INST:01UCNY_INST?url_ver=Z39.88-2004&ctx_ver=Z39.88-2004&ctx_enc=info:ofi/enc:UTF-8&rft_val_fmt=info:ofi/fmt:kev:mtx:book",
   primapi: "https://api-na.hosted.exlibrisgroup.com/primo/v1/search?vid=01UCNY_INST:Services&tab=Everything&scope=MyInst_and_CI&conVoc=false&apikey=l7xxaa726f9cf9f74f048296f374d9ec74f5",
   oclcapi: "https://api-na.hosted.exlibrisgroup.com/primo/v1/search?vid=01UCNY_INST:Services&tab=oclc&scope=oclc&conVoc=false&apikey=l7xxaa726f9cf9f74f048296f374d9ec74f5",
   gobooks: "https://www.googleapis.com/books/v1/volumes?",
 };

 const urikeys = {
   "gobooks": { "rft.btitle": "intitle:", "rft.au": "inauthor:", "rft.publisher": "inpublisher:" },
   "oclcapi": { "rft.btitle": "title,exact,", "rft.au": "creator,contains,", "rft.pubdate": "creationdate,contains,", "rft.isbn": "isbn,contains,"},
   "primapi": { "rft.btitle": "title,contains,", "rft.au": "creator,contains,", "rft.pubdate": "cdate,contains,", "rft.isbn": "isbn,contains,"},
   "almasru": { "rft.btitle": "alma.title==", "rft.au": "alma.creator=", "rft.pub": "alma.publisher=", "rft.year": "alma.main_pub_date==" }
};


 // function watchThumbs() {
 //   const observedNode = document.querySelector('.thumbnails');
 //   const config = { attributes:false, childList:true, subtree:true };

 //   const callback = function(mutationsList, observer) {
 //     for (const mutation of mutationsList) {
 //       if (mutation.type === 'childList') {
 //         let anchors = document.querySelectorAll(".thumbnails > a");
 //         //let anchor = mutation.addedNodes[0];
 //         // if (!anchor.classList.contains("opacity-none")) {
 //         //      anchor.classList.replace("opacity-none", "opacity-full");
 //         // }
 //         anchors.forEach(anchor => {
 //           if (!anchor.classList.contains("opacity-none")) {
 //              anchor.classList.replace("opacity-none", "opacity-full");
 //           }
 //         });
 //       }
 //     }  
 //   }
 //   const observer = new MutationObserver(callback);
 //   observer.observe(observedNode, config);
 // }
 // watchThumbs();

</script>
</html>


