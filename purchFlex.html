<!DOCTYPE html>
<html lang="en_US"> 
<head>
<title>Schaffer Library Find and Request</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="author: david fuller, title: purchase request">
<meta name="keywords" content="schaffer library purchase request form">
<link rel="icon" href="icons/request.png" type="image/png" sizes="84x84"> 
<style>
  
  :root {
     box-sizing: inherit;
  }

  *, ::before, ::after {
    box-sizing: border-box;    
    border-radius: 0.4em;   
    padding: 0.35em;
    font-family: Source Sans Pro, Helvetica Neue, sans-serif;
    font-size: 15px;
  }
  
  .container {
    display: grid;
    grid-template-columns: 1fr 2fr;
    grid-template-rows: 0.5fr 2fr 1fr 0.5fr;
    grid-auto-flow: row;
    grid-template-areas: 
    "requestform  panel"
    "requestform  panel"
    "requestform  panel"
    "requestform  panel";
    width: 50%;
    height: 25em;
    box-shadow: 1px 0 1px 1px #822433cc inset;
    border: 1px ridge #822433cc;
    margin: 1em; 
    color: #000000cc;
    background: #ededed;
    transition:  all .4s cubic-bezier(.25,.8,.25,1);
  }
  .requestform {
    grid-area: requestform;
    grid-template-rows: 1fr 7fr 1fr 1fr;
    grid-template-areas:
      "header"
      "inputels"
      "status"
      "buttons";
  }    
  .header { 
    grid-area: header; 
    height: 10%;
  } 
  ul.flexer { 
    grid-area: inputels; 
    height: 66%;
  }  
  .status {
    grid-area: status;
    color: red;
    font-size: 0.9em;
    letter-spacing: .08em;
    height: 16%;
    padding: 0;
    justify-self: top;
  }
  .buttons { 
    grid-area: buttons; 
    padding: 0;
    height:8%;
  }
  button {  
    max-height: 2.5em;
    padding: 0.1em 0.35em;
    color: white;
    background: #822433;
    border: 0.5em outset #82243399;
  } 
  input {
    padding: 0.25em;
    border: 2px inset #dedede;
    border-radius: 0.25em;
    width: 18em;
    background-color: whitesmoke;
  }
  ul { 
    list-style-type: none; 
    margin: 0;
    padding: 0;
  }  
  ul.flexer > li {
    display: flex;
    flex-wrap: nowrap;
    padding: 0.25em 0;
  }
  ul.flexer > li > label {
    letter-spacing:.08em;
    width: 4.25em; 
  }    
  input[type="checkbox"] {
    width: 1em; 
    height: 1.5em;
  }  
  input[data-name="mms"], input[data-name="oclcid"] {
    line-height: 0.01;
  }
  .panel {
    display: grid;
    grid-area: panel;
    grid-template-rows: 1fr 1fr 8fr;
    grid-template-areas:
      "helpme"
      "blockquote"
      "thumbnails"; 
      flex-direction: column nowrap;
  } 
  .help {
    grid-area: helpme;
    height: 10%;
  }
  .panel > img {
    margin: 4px 0;
    height: 2.5em;
    padding: 0;
  }
  .blockq {
    grid-area: blockquote; 
    padding: 0;
    margin: 0.35em 0;
  }  
  .thumbnails { 
    grid-area: thumbnails;
    display: flex;
    flex-flow: column nowrap;
    overflow-y: scroll;
    padding: 0;    
  }  

  .thumbnails > a {
    display: flex;  
    flex: 0 0 auto;
    box-shadow: inset 0 0 0.15em 0.04em #822433cc;
    border: 1px outset #822433cc;
    background: #F6F6F6;
    margin: 0.15em 0;
    text-decoration: none;
    font-weight: 480;
    font-size: 0.9em;
    opacity: 0.8;
    padding: 0.5em;
  }
  .thumbnails > a:hover {
    border-style: inset;
    background: white;
    opacity: 1;
  } 
  .promptxt {
    box-shadow: inset 2px 1px 2px 0 #822433cc;
    margin: 0;
  } 
  .cite {
    flex: 0 0 80%;
    padding: 0;
  }
  .cite > span {
    padding: 0;
    flex-wrap: wrap;
  }
  
  a > img {
    padding: 0.75em;
    max-height: 5em;
    min-height: 3.5em;
  }
  .rtype {
    font-size: 0.75em;
    font-weight: 600;
    letter-spacing: .07em;
    text-transform: uppercase;
  }
  .rtype-video {
    color: #822433;
  }
  .rtype-book {
    color: #28F;
  }
  .btitle {
    font-weight: 600;
  }
  .location {
    margin: 0.5em 0;
    text-decoration: none;
    cursor: pointer;
  }
  .littlebox { 
    position: absolute;
    display: inline-block;
    top: 3em;
    width: auto;
    margin: 4px 0;
    opacity: 0;
    font-size: 0.1em;
    line-height: 0.1em;
    transition: opacity 1.4s ease-out;
  }
  .expandbox { 
    z-index: 10; 
    font-size: 0.9em;
    line-height: 1em;
    opacity: 1;
    background-color: white;    
  } 
  </style>
</head>
 
<body>
    <div class="container"> 
      <div class="panel">
        <img src="icons/help.png" onclick="showHelp();">
          <span class="help littlebox">
          <ul>Requesting books and videos:   
            <li>Enter an ISBN&lt;TAB&gt; or other data</li> 
            <li>distinctive keywords usually suffice...</li> 
            <li>We'll check availability and populate a request</li>
            <li>remember: login to see all options</li>
            <li></li>
            <ul>Best practices for locating videos:
              <li><b>Author</b> varies, best to omit</li>
              <li><b>Pub.</b> refers to studio or distributor</li>     
              <li><b>Year</b> refers to release, not production</li> 
              <li>remember to check the "video" box!</li>
              <li></li>
              <ul><b>[title, pub, year]</b> examples:
                <li>The Way We Were, Columbia, 1999</li>
                <li>Dersu Uzala, kino, 2000</li>
                <li>dersu, Kino</li>
              </ul>
            </ul>
          </ul>
          </span>
          <div class="blockq">
            <blockquote></blockquote>
          </div>
         <!--  <div class="anchors"> -->
            <div class="thumbnails"></div>
      <!--     </div> -->
      </div>

      <div class="requestform">     
          <span class="header">Locate, then request</span>
          <ul class="flexer">
            <li>
              <input type="hidden" name="rft.oclcnum" data-name="oclcid" value=""> 
              <input type="hidden" name="rft.mms_id" data-name="mms" value="">
              <input type="hidden" name="rft.edition" data-name="edition" value="">
            </li><li>
              <label for="rft.isbn">ISBN</label>
              <input type="search" name="rft.isbn" data-name="isbn" data-gbname="industryIdentifiers" autocomplete="off"  placeholder="add then press <TAB>" value="" autofocus>
            </li><li>
              <label for="rft.btitle">Title</label>
              <input type="search" name="rft.btitle" data-name="btitle" data-gbname="title" value="">
            </li><li>
              <label for="rft.au">Author</label>
              <input type="search" name="rft.au" data-name="addau" data-gbname="authors" value="">
            </li><li>
              <label for="rft.publisher">Pub.</label>
              <input type="search" name="rft.publisher" data-name="pub" data-gbname="publisher" value="">
            </li><li>  
              <label for="rft.pubdate">Year</label>
              <input type="search" name="rft.pubdate" data-name="creationdate" data-gbname="publishedDate" pattern="\d{4}" value="" minlength="4" maxlength="4">
            </li><li>
              <label for="video">Video?</label> 
              <input id="ristype" type="checkbox" value="VIDEO" name="videos">
            </li> 
          </ul>

          <div class="status"></div>
          <div class="buttons">
            <button name="reset" onclick="startOver();">&circlearrowleft;</button> 
            <button name="sub" onclick="searchController();">Locate data</button> 
          </div>          
      </div>
  </div> 
</body>

<script>


    "use strict";
   'use strict';
   let searchkeys = {}, ISBN;
   const status = document.querySelector(".status");
   const thumbs = document.querySelector(".thumbnails");
   const RISTYPE = document.querySelector("#ristype");
   const Thumb = getThumb();
   const { log } = console;

   let recordset = {};
   ["Primo", "Google", "Worldcat" ].forEach(src => {
      recordset[src] = {records: [], totrecs: () => { return recordset[src].records.length; }, found: () => { return recordset[src].records.length > 0; }}
    });
   
//// makers -- normalize results
   async function makeAnchors(records) {
      let API = getSource();
      getHeader(API);

      records.forEach(record => {
       let newitem = Thumb.cloneNode(true), item;
       let [anchor, div, img] = newitem.querySelectorAll("a, div, img");

        if (API === "Google") {
          item = makeGoogle(record);
          img.src = (record.imageLinks && record.imageLinks.smallThumbnail) ? record.imageLinks.smallThumbnail : "icons/icon_book.png";
        } else {
          item = makeAPI(record);
          fetchThumbnail(item['isbn']).then(thumburl => {
            img.src = thumburl ? thumburl : `icons/icon_${item["ristype"]}.png`;
          });
        } 

        div.innerHTML = getCitation(item);
        thumbs.appendChild(newitem);
      });
   }

   function makeAPI(record) {
       let item = {};
       ['isbn', 'btitle', 'au', 'creationdate', 'pub', 'ristype', 'addau', 'date', 'type', 'description', 'edition', 'format', 'oclcid', 'mms'].forEach(el => {
         if (record.hasOwnProperty(el)) { item[el] = String(record[el]).trim(); }
       });
       item["creationdate"] = item.hasOwnProperty("creationdate") ? item["creationdate"] : item.hasOwnProperty("date") ? item["date"] : undefined;
       item["ristype"] = item.hasOwnProperty("ristype") ? item["ristype"].toLowerCase() : item.hasOwnProperty("type") ? item["type"].toLowerCase() : undefined;
       item["au"] = item.hasOwnProperty("au") ? item["au"] : record.hasOwnProperty("addau") ? record["addau"] : undefined;
       for (let key of Object.keys(item)) { if (item[key] === undefined || item[key] === "") { delete item[key]; } }
       return item;
   }

  function makeGoogle(record) {
     let item = {};
     item['isbn'] = (record.industryIdentifiers[1]) ? record.industryIdentifiers[1].identifier : record.industryIdentifiers[0].identifier;
     item['btitle'] = (record["title"] && Array.isArray(record['title'])) ? record["title"][0] : record["title"];
     item['au'] = (record["authors"] && Array.isArray(record['authors'])) ? record["authors"][0] : record["authors"];
     item['creationdate'] = record["publishedDate"] ? record["publishedDate"].match(/^\d{4}/)[0] : "";
     item['pub'] = (record["publisher"] && Array.isArray(record['publisher'])) ? record["publisher"][0] : record["publisher"];
     item["ristype"] = "book";
     return item;
  }

//// controller
 async function searchController() {
   clearAnchors();
   document.querySelectorAll('[name^=rft]').forEach(el => {
       if (el.value) {
        searchkeys[el.name] = el.value.trim().toLowerCase();
       } else if (searchkeys[el.name]) {
        delete searchkeys[el.name];
       }
   });

   let ISBN_SEARCH = searchkeys["rft.isbn"] ? true : false;
   let TITL_SEARCH = (searchkeys["rft.btitle"] && !ISBN_SEARCH) ? true : false;
   status.innerHTML = "Searching...";
   let time0 = performance.now();

   await fetchJSON("Primo").then(records => {
     if (records && records.docs) {
       const results = records.docs.map(item => {
         return { ...item.pnx.addata, ...item.pnx.display, ...item.pnx.control };
       });
       recordset["Primo"].records = filterAPI(results);
     }
   });

   if (ISBN_SEARCH && !recordset["Primo"].found()) {
     await fetchJSON("Google").then(gb_records => {
       if (gb_records && gb_records.items) {
         recordset["Google"].records = gb_records.items.map(item => {
           return { ...item.volumeInfo, ...item.saleInfo };
         });
       }
     });
   }

   if (!recordset["Primo"].found() && !recordset["Google"].found()) {
     await fetchJSON("Worldcat").then(oclc_records => {
       if (oclc_records && oclc_records.docs) {
         const results = oclc_records.docs.map(item => {
           return { ...item.pnx.addata, ...item.pnx.display, ...item.pnx.control };
         });
         recordset["Worldcat"].records = filterAPI(results);
       }
     });
   }

   let time1 = performance.now();
   status.innerHTML = `Search completed: ${((time1 - time0)/1000).toFixed(2)}s<br>`; 
   
   let source = getSource();
   log(source);
   status.innerHTML += `${recordset[source].totrecs()} record(s) found in ${source}`;
   makeAnchors(recordset[source].records);
 }

//// UI helpers
  function startOver() {
   document.querySelectorAll('[data-name]').forEach(el => { el.value = ""; });
   RISTYPE.checked = false;
   status.innerHTML = "";
   document.querySelector('input[name="rft.isbn"]').focus();
   clearAnchors();
   return;
  }

  function clearAnchors() {
   if (thumbs && thumbs.firstChild) {
     while (thumbs.firstChild) { thumbs.removeChild(thumbs.firstChild); }
   }
   return;
  }

  function showHelp() {
   let box = document.querySelector(".littlebox");
   box.classList.toggle("expandbox");
  }
 
//// getters 
  function getHeader() { 
   let blq = document.querySelector("blockquote");
  
   if (getSource() === "Primo") {
     blq.innerHTML = `<b>Owned!...maybe...check availability or place a request.</b><br>note: <i>login to Primo</i> to see request options or status of existing requests.`;
   } else {
     blq.innerHTML = `<b>Not owned</b>...select record to use data in requesting [ill, purchase].`;
   }
   blq.classList.add("promptxt");
   return;
 }

 function getThumb() {
    let anchor = document.createElement('a');
    let div = document.createElement('div');
    //let figure = document.createElement('figure');
    let img = document.createElement('img');
    //figure.classList.add("thumb"); 
    div.classList.add("cite");
    //figure.appendChild(img); 
  
    anchor.appendChild(div)
    anchor.appendChild(img);
    let fragment = new DocumentFragment();
    fragment.appendChild(anchor);
    return fragment;
 }

 function getCitation(record) {
   let location = getTargetURL(record);
   let citation = (record.hasOwnProperty("ristype")) ? `<span class="rtype rtype-${record.ristype}">${record.ristype}</span><br>`: "";
   citation += (record.hasOwnProperty("btitle")) ? `<span class="btitle">${record["btitle"]}</span><br>` : "";
   citation += (record.hasOwnProperty("au") && record["au"] !== "") ? `<span class="author">${record["au"]}</span>` : "";
   citation += (record.hasOwnProperty("edition") && record["edition"] !== "") ? `<br><span class="edition">${record["edition"]}</span>` : "";
   citation += formatPub(record["pub"], record["creationdate"]);
   citation += (record.hasOwnProperty("format") && record["format"] !== "") ? `<br><span class="format">${record["format"]}</span>` : "";
   citation += `<br><a href='javascript:window.open("${location}", "_blank");' class="location">view or request in Primo</a>`;
   return citation;
 }

 function formatPub(publisher, date) {
    let tmpstr = [];
    if (publisher && publisher !== "") { tmpstr.push(publisher); }
    if (date && date !== "") { tmpstr.push(date); }
    return (publisher !== "" && date !== "") ? `<br><span class ="pub">${tmpstr.join(':')}</span>` : `<br><span class="pub">${tmpstr.toString()}</span>`;
 }

 function getTargetURL(record) {
   const searchParams = ['isbn:rft.isbn', 'btitle:rft.btitle', 'addau:rft.au', 'edition:rft.edition', 'pub:rft.publisher', 'creationdate:rft.pubdate', 'oclcid:rft.oclcnum', 'mms:rft.mms_id'];
   let url = new URL(urls.primreq);
   searchParams.forEach(params => {
     let [rparam, sparam] = params.split(":");
     if (record[rparam] !== undefined) {
       url.searchParams.set(sparam, record[rparam]);
     }
   });
   return url;
 }

 function getURI(targ, keys) {
   let terms = [];
   for (let key of Object.keys(searchkeys)) {
     if (keys[key] && searchkeys[key]) {
       terms.push(keys[key] + searchkeys[key]);
     }
   }
   let uri = (targ === "Google") ? uri = terms.join(" ") : terms.join(",AND;");
   return uri;
 };

 function getURL(target) {
   let url = new URL(urls[target]);
   if (target === "Google") {
     url.searchParams.set("q", "isbn:" + ISBN);
   } else {
     url.searchParams.set("q", getURI(target, urikeys[target]));
     if (RISTYPE.checked) {
       url.searchParams.set("qInclude", "facet_rtype,include,videos");
     } else {
       url.searchParams.set("multiFacets", "facet_rtype,exact,books|,|facet_rtype,exact,videos");
     }
   }
   return url;
 }

  function getSource() {
    let source;
    [ "Primo", "Google", "Worldcat" ].forEach(src => {
      if (recordset[src].found()) { source = src; }
    });
    return source;
  }

 //// event listeners 
 document.querySelector('input[name="rft.isbn"]').addEventListener("blur", function(evt) {
   if (evt.target.value) {
     ISBN = evt.target.value.replace(/[^\dxX]/g, "");
     if (ISBN.length === 10 || ISBN.length === 13) {
       searchController();
     }
   }
 }, false);

//// urls and uris
  const urls = {
   primreq: "https://union-psb.primo.exlibrisgroup.com/openurl/01UCNY_INST/01UCNY_INST:01UCNY_INST?url_ver=Z39.88-2004&ctx_ver=Z39.88-2004&ctx_enc=info:ofi/enc:UTF-8&rft_val_fmt=info:ofi/fmt:kev:mtx:book",
   Primo: "https://api-na.hosted.exlibrisgroup.com/primo/v1/search?vid=01UCNY_INST:Services&tab=Everything&scope=MyInst_and_CI&conVoc=false&apikey=l7xxaa726f9cf9f74f048296f374d9ec74f5",
   Worldcat: "https://api-na.hosted.exlibrisgroup.com/primo/v1/search?vid=01UCNY_INST:Services&tab=oclc&scope=oclc&conVoc=false&apikey=l7xxaa726f9cf9f74f048296f374d9ec74f5",
   Google: "https://www.googleapis.com/books/v1/volumes?",
  };

  const urikeys = {
   "Google": { "rft.btitle": "intitle:", "rft.au": "inauthor:", "rft.publisher": "inpublisher:" },
   "Worldcat": { "rft.btitle": "title,exact,", "rft.au": "creator,contains,", "rft.pubdate": "creationdate,contains,", "rft.isbn": "isbn,contains,"},
   "Primo": { "rft.btitle": "title,contains,", "rft.au": "creator,contains,", "rft.pubdate": "cdate,contains,", "rft.isbn": "isbn,contains,"},
   "almasru": { "rft.btitle": "alma.title==", "rft.au": "alma.creator=", "rft.pub": "alma.publisher=", "rft.year": "alma.main_pub_date==" }
  };

//// filters
  function filterAPI(recordset) {
   let records = recordset.filter(record => {
     let FILTER = true;

     if (searchkeys.hasOwnProperty('rft.btitle')) {
       let recordtitle = record.btitle ? record.btitle : record.title;
       if (recordtitle) {
         recordtitle = recordtitle.toString().toLowerCase();
         let searchtitle = searchkeys['rft.btitle'];
         FILTER = FILTER && recordtitle.includes(searchtitle);
       }
     }
     if (searchkeys.hasOwnProperty('rft.pubdate') && FILTER) {
       let recordate = record.creationdate ? record.creationdate : record.date;
       if (recordate) {
         recordate = recordate.toString().toLowerCase();
         let searchdate = searchkeys['rft.pubdate'];
         FILTER = FILTER && recordate.includes(searchdate);
       }
     }
     if (searchkeys.hasOwnProperty('rft.publisher') && FILTER) {
       let recordpub = record.pub ? record.pub : record.publisher;
       if (recordpub) {
         recordpub = recordpub.toString().toLowerCase();
         let searchpub = searchkeys['rft.publisher'];
         FILTER = FILTER && recordpub.includes(searchpub);
       }
     }
     if (searchkeys.hasOwnProperty('rft.au') && FILTER) {
       let recordau = record.au ? record.au : record.addau;
       if (recordau) {
         recordau = recordau.toString().toLowerCase();
         let searchau = searchkeys['rft.au'];
         FILTER = FILTER && recordau.includes(searchau);
       }
     }
     if (record.hasOwnProperty("ristype") && FILTER) {
       let ristype = record.ristype ? String(record.ristype).trim().toLowerCase() : String(record.type).trim().toLowerCase();
       if (ristype) {
         FILTER = FILTER && (ristype === "video" || ristype === "book");
       }
     }
     return FILTER;
   });
   return records;
  }

//// fetch data
  async function fetchThumbnail(isbn) {
      if (!isbn) { return false; }

      let bibkey = "isbn:" + isbn,
      data, response, oldata, olresponse, imgurl;
      let url = new URL(urls.Google);
      url.searchParams.set("q", bibkey);

      try {
        response = await fetch(url.href);
        data = await response.json();
      } catch (e) {
        status.innerHTML = e;
      }

      if (!response.ok) {
        try {
          olresponse = await fetch(`https://covers.openlibrary.org/a/isbn/${isbn}-S.jpg`);
          let oldata = await olresponse.blob();
        } catch (e) {
          status.innerHTML = e;
        }
      }

      if (response && response.ok) {
        if (data && data.totalItems === 1) {
          let thumbnail = data.items[0].volumeInfo.imageLinks;
          if (thumbnail && thumbnail.smallThumbnail) {
            imgurl = thumbnail.smallThumbnail;
          }
        }
      } else if (olresponse && olresponse.ok) {
        if (oldata && oldata.url) {
          log("OL thumbnail needed", isbn)
          imgurl = data.url;
        }
      }

      return imgurl;
  }

  async function fetchJSON(target) {
    let data;
    try {
      let url = getURL(target);
      let response = await fetch(url.href);
      data = await response.json();
    } catch (e) {
      status.innerHTML = e;
    }
    return data;
  }


</script>
</html>


